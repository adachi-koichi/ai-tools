---
name: self-update
description: 会話セッションを分析してagent、command、skill、ruleを作成・更新する。ユーザーが「学びを保存して」「このパターンをスキル化して」「ルールとして追加して」と言った時、または会話終了時に有用なパターンを検出した時に使用する。/self-updateコマンドで明示的に呼び出し可能。
---

# Self Update

会話セッションから学習パターンを抽出し、Claude Codeの設定（agent、command、skill、rule）として永続化する。

## 出力タイプ

各タイプの詳細は [references/types.md](references/types.md) を参照。
テンプレートは [references/templates.md](references/templates.md) を参照。

| タイプ | 用途 | 保存先 |
|--------|------|--------|
| agent | 専門的なサブエージェント | `.claude/agents/<name>.md` |
| command | スラッシュコマンド | `.claude/commands/<name>.md` |
| skill | 拡張機能パッケージ | `.claude/skills/<name>/SKILL.md` |
| rule | 行動ルール・制約 | `settings.json`の`rules`配列 |

## ワークフロー

### ステップ1: トリガー判定

**明示的トリガー:**
- `/self-update` - セッション全体を分析
- `/self-update <type>` - 特定タイプのみ生成（agent/command/skill/rule）
- ユーザーの明示的な指示（「スキル化して」「ルール追加して」等）

**自動提案トリガー（proactive）:**
- 同じパターンの繰り返し検出（3回以上）
- ユーザーによる修正の蓄積
- 複雑なワークフローの完了後

### ステップ2: セッション分析

会話全体をスキャンし、以下を検出:

**パターン検出:**
1. **反復パターン** - 同じ操作の繰り返し → command/skill候補
2. **修正パターン** - ユーザーからの訂正 → rule候補
3. **専門的タスク** - 特定ドメインの深い作業 → agent/skill候補
4. **好み・制約** - 暗黙的なルール → rule候補

**シグナル優先度:**
- HIGH: 明示的な修正、エラー訂正
- MEDIUM: 暗黙的な好み、成功パターン
- LOW: 観察事項、改善提案

### ステップ3: 出力タイプ選択

検出パターンに基づき最適なタイプを提案:

```
検出結果: [pattern description]

推奨される出力タイプ:
1. [type] - [reason]
2. [type] - [reason]

どのタイプで保存しますか？
```

ユーザーに確認後、タイプを決定。

### ステップ4: 保存先確認

```
保存先を選択してください:
1. ~/.claude/ (グローバル - 全プロジェクトで使用)
2. ./.claude/ (プロジェクト固有)
```

### ステップ5: 既存ファイル確認

保存先に同名ファイルが存在するか確認:

```
# 確認対象
- agent: .claude/agents/<name>.md
- command: .claude/commands/<name>.md
- skill: .claude/skills/<name>/SKILL.md
- rule: settings.jsonのrules配列
```

**ファイルが存在しない場合:** → ステップ6へ

**ファイルが存在する場合:**

```
既存ファイルが見つかりました: [path]

更新方法を選択してください:
1. マージ (既存内容に追記・統合)
2. 上書き (既存内容を置き換え)
3. キャンセル
```

**マージの場合:**
1. 既存ファイルをReadツールで読み込み
2. 追加・変更箇所を特定
3. 差分をユーザーに表示:
   ```
   変更内容:
   + [追加される内容]
   ~ [変更される内容]
   - [削除される内容]（あれば）
   ```
4. 確認後、Editツールで変更を適用

**ruleの場合（settings.json）:**
1. 既存のsettings.jsonを読み込み
2. rules配列に新しいルールを追加（重複チェック）
3. 既に同じルールがあれば通知してスキップ

### ステップ6: コンテンツ生成

選択されたタイプに応じてテンプレートを使用し、コンテンツを生成。

**新規作成の場合:**
1. テンプレート読み込み（references/templates.md参照）
2. 検出パターンからコンテンツ抽出
3. ドラフト生成・表示
4. ユーザー確認
5. Writeツールでファイル作成

**編集の場合:**
1. 既存ファイルの構造を解析
2. 追加・変更箇所を特定
3. Editツールで差分を適用

### ステップ7: 保存・反映

1. ファイル作成/更新完了
2. 変更サマリー表示
3. （オプション）Git操作

```
完了:
- ファイル: [path]
- 操作: [新規作成 / マージ / 上書き]
- 変更内容: [summary]

Gitにコミットしますか？ (y/n)
```

## 使用例

### 例1: コマンド化

```
User: いつもgit stashしてからpullしてstash popしてるんだけど
Claude: このパターンをコマンドとして保存しますか？

/git-safe-pull として保存すると:
- git stash
- git pull
- git stash pop

を自動実行できるようになります。
```

### 例2: ルール追加

```
User: コミットメッセージは日本語で書いて
Claude: このルールを保存しますか？

settings.jsonに追加:
"rules": ["コミットメッセージは日本語で記述する"]
```

### 例3: スキル生成

```
User: Miro APIとの連携を何度かやったけど、これまとめて
Claude: Miro API連携をスキルとして保存しますか？

.claude/skills/miro/SKILL.md として:
- API認証方法
- ボード操作
- アイテム作成

を含むスキルを生成します。
```

### 例4: 既存コマンドの更新

```
User: git-safe-pullにrebaseオプションも追加して
Claude: 既存ファイルが見つかりました: .claude/commands/git-safe-pull.md

更新方法を選択してください:
1. マージ (既存内容に追記・統合)
2. 上書き (既存内容を置き換え)

User: 1

Claude: 変更内容:
+ 引数: --rebase オプションのサポート
+ ワークフロー: rebase指定時は git pull --rebase を使用
~ 説明文を更新

この変更を適用しますか？
```

### 例5: 既存ルールへの追加

```
User: TypeScriptではanyを使わないようにして
Claude: 既存のsettings.jsonにルールを追加します:

現在のrules:
- "コミットメッセージは日本語で記述する"

追加するルール:
+ "TypeScriptでany型を使用しない"

追加しますか？
```

## 注意事項

1. **既存ファイルの確認**: 同名のファイルが存在する場合は上書き/マージを確認
2. **依存関係**: スキルに必要なツールや環境変数を明記
3. **テスト不要**: 生成ファイルは設定ファイルなのでテスト不要
4. **最小限の生成**: 必要な部分のみ抽出し、冗長な内容は避ける
